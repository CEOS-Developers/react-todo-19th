### 🔗 링크
https://react-todo-19th-dh.vercel.app/
<br/>

### 📌 기능구현
- 할 일 입력창(Form)에 텍스트를 입력하고 enter 혹은 버튼클릭으로 할 일 추가
- 할 일 추가/삭제 시 애니메이션
- 할 일 삭제
- 할 일 완료 표시 
- localStorage에 할 일, 완료 상태 저장
- 모바일 (768px 이하) 반응형 스타일
- 할 일과 완료된 할일 카운트

<br/>

### 🤔 후기
전 과제와 비교해보기 위해 똑같은 인터페이스를 React로 구현하는 것을 목적으로 이번 2주차 과제를 해보았습니다.
html, css, javascript로 투두리스트를 구현하는 것보다 react 라이브러리를 이용해서 구현하는 것이 확실히 편리하다는 것을 느꼈습니다.<br/>
특히 useState나 useEffect같은 React Hook으로 상태관리 하는 것이 DOM을 조작하는 것보다 직관적이고 관리하기 용이하고,<br/>
StyledComponent로 스타일 관리하는 것이 적용이 휠씬 빠르고 직관적인 것 같습니다. 

<br/>

### 📄 Key Questions

**1. Virtual-DOM은 무엇이고, 이를 사용함으로서 얻는 이점은 무엇인가요?**
> Virtual DOM은 UI의 이상적인 또는 “가상”적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 “실제” DOM과 동기화하는 프로그래밍 개념입니다.<br/>
> DOM의 가벼운 복사본으로, 웹 애플리케이션의 상태 변화를 메모리 내에서 빠르게 처리하고 최소한의 DOM 업데이트를 통해 변화를 반영하는 방식입니다.<br/>
> 실제 DOM은 웹 페이지의 구조와 내용을 브라우저가 이해하고 렌더링하는 데 사용되는 구조화된 트리 모델입니다.<br/>
> 반면, Virtual-DOM은 변화가 있을 때 전체 트리를 다시 그리지 않고 변화가 필요한 부분만 식별하여 DOM에 효율적으로 반영함으로써,<br/>
> 불필요한 DOM 조작을 최소화하고 애플리케이션의 성능을 향상시키는 주요 차이점을 가집니다.<br/>
> 주로 React, Vue 등 라이브러리 및 프레임워크에서 널리 사용되어집니다.
>
> 
> **이점**<br/>
> 1. 효율적인 업데이트<br/>
> Virtual-DOM은 애플리케이션의 상태가 변경될 때마다 전체 UI를 처음부터 다시 그리는지 않고, 변경된 부분만 실제 DOM에 반영됩니다.<br/>
> 이는 DOM 조작 비용을 줄여 성능을 향상시킵니다.<br/>
> 2. 빠른 성능<br/>
> Virtual-DOM은 메모리 내에서 작동하기 때문에, 변경사항을 빠르게 계산하고 최소한의 실제 DOM 업데이트로 결과를 반영할 수 있습니다.<br/>
> 이는 특히 복잡한 인터페이스에서 성능 이점을 제공합니다.
> 3. 크로스 플랫폼 호환성<br/>
> Virtual-DOM을 사용하면, 웹 브라우저 뿐만 아니라 모바일 애플리케이션(React Native와 같은)에서도 UI를 렌더링할 수 있습니다.<br/>
> 이는 개발자가 다양한 플랫폼에서 일관된 사용자 경험을 제공할 수 있도록 합니다.
<img width="614" alt="image" src="https://github.com/ddhelop/react-todo-19th-dh/assets/132553964/daf68eb1-751a-464a-b86a-dd4ec830ecb9"><br/>
출처 : https://www.wikitechy.com/interview-questions/reactjs/what-is-react-dom/

<br/>

**2. 미션을 진행하면서 느낀, React를 사용함으로서 얻을수 있는 장점은 무엇이었나요?**
> 1. 다양한 라이브러리(prettier, eslint, styled-component)를 사용할 수 있어 다양한 기능들을 편리하게 적용할 수 있었습니다.<br/>
> 
> 2. 전 과제에서 할 일 목록을 구현할 때, DOM 조작을 이용해서 element들을 추가하고, 삭제해서 관리했는데,<br/>
> 이번 과제에서는 useState를 이용해서 할밀들을 배열로 관리하여, 보다 더 쉬운 아이디어를 활용하여 구현이 가능했습니다.<br/>
> 
> 3. 이번 과제에선 한가지 기능을 구현해서 컴포넌트를 통해 재사용성 활용을 하지 못했는데, 확실히 컴포넌트를 사용하여 UI를 구축하면,<br/>
> 코드의 재사용성을 높이고, 대규모 애플리케이션의 개발과 유지보수를 용이할 것을 느꼈습니다.
  
<br/>

**3. React에서 상태란 무엇이고 어떻게 관리할 수 있을까요?**
> React에서 상태(state)는 컴포넌트의 상태 정보를 담고 있는 객체로,<br/>
> 컴포넌트의 동작, 콘텐츠, 그리고 렌더링에 영향을 미치는 데이터를 말합니다.<br/>
> 상태는 동적인 데이터를 다룰 때 중요하며, 사용자 상호작용이나 시간의 경과에 따라 변경될 수 있습니다.<br/>
><img width="523" alt="image" src="https://github.com/ddhelop/react-todo-19th-dh/assets/132553964/4c47fff5-11a4-4f89-b5ae-ab41b8fe7a1d"><br/>
출처 : https://dev.to/stuxnat/final-react-project-2poi
> 1. 컴포넌트 내부 상태(State)<br />
> 각 React 컴포넌트는 자신의 state 객체를 가질 수 있으며,
> **this.setState()(클래스 컴포넌트)** 또는 **useState 훅(함수 컴포넌트)** 을 사용하여 상태를 업데이트할 수 있습니다.<br/>
> 상태가 변경될 때마다 React는 컴포넌트를 재렌더링하여 사용자 인터페이스를 최신 상태로 유지합니다.
> 
> 2. React Hooks <br/>
> useState, useReducer, useContext와 같은 React Hooks는 함수 컴포넌트에서 상태 관리를 보다 선언적으로 할 수 있게 해줍니다.<br/>
> **useState**는 간단한 상태 값 관리에 사용되며, **useReducer**는 복잡한 상태 로직을 다룰 때 유용합니다.<br/>
> **useContext**는 Context API와 함께 사용되어 컴포넌트 트리를 통한 상태 공유를 간소화합니다.
>
> 3. Redux, Recoil 상태 관리 라이브러리<br/><br/>
> **Recoil**<br>
> 애플리케이션 전역에서 상태를 관리할 수 있으며, 컴포넌트 간 상태 공유가 용이해집니다.<br/>
> 특히, 원자(atom)라는 개념을 사용하여 상태의 단위를 정의하고, 선택자(selector)를 통해 상태를 파생시키는 기능을 제공합니다.<br/><br/>
> **Redux**<br/>
> 전체 애플리케이션의 상태를 하나의 저장소(store)에서 관리합니다.<br/>
> 이 저장소는 애플리케이션의 single source of truth으로 작동합니다.<br/>
> Redux는 액션(action)과 리듀서(reducer)를 사용하여 상태 변화를 관리합니다.<br/>
> 액션은 상태 변화를 일으키는 사건을 설명하는 객체이며, 리듀서는 이러한 액션을 받아 이전 상태를 새 상태로 변환하는 순수 함수입니다. 


<br/>

**4. Styled-Components 사용 후기 (CSS와 비교)**
> Styled-Component는 컴포넌트 기반 스타일링으로 똑같은 스타일 속성을 컴포넌트로 재사용하는 것이 편리했습니다.<br/>
> 또 JavaScript 파일 내에 스타일과 컴포넌트 로직이 함께 있기 때문에,<br/>해당 태그 관련 코드를 찾고 관리하기가 더 쉬워 CSS에 비해 스타일 수정이 빠르고 편리했습니다.<br/>
> 
> 하지만 한가지 아쉬운점은 단순히 html 구조를 변경하고 추가할때 스타일속성을 적용하려고 컴포넌트를 생성하고 연결하는 과정이 다소 번거로운 작업이라 생각했습니다.
<br/>


